# 동적프로그래밍


## 01. 배낭채우기 문제

당신은 4파운드의 짐을 넣을 수 있는 도둑이다. 훔칠 수 있는 물거은 3개가 있다.
- 스테레오 / $3000 / 4파운드
- 노트북 / $2000 / 3파운드
- 기타 / $1500 / 1파운드


< 단순한 방법 >

모든 물건의 조합을 시도해서 각 경우의 총 가치를 모두 구해본 다음, 가장 가치가 높은 경우를 선택하면 된다. 이 방법은 가능하지만 너무 느리다. 물건을 추가할 때마다 경우의 수는 두 배가 된다. 이 알고리즘의 실행 시간은 O(2^n)시간이 된다. 물건이 32개이면 경우의 수는 40억개가 된다.


< 동적 프로그래밍 >

최적해를 계산하려면 동적 프로그래밍을 사용하면 된다. 동적 프로그래밍은 하위의 작은 문제들을 풀고, 이를 이용해서 더 큰 문제를 풀어나가는 방법이다. 모든 동적 프로그래밍 알고리즘은 격자(grid)로부터 시작한다.

배낭 채우기 문제를 풀 때 열은 1부터 4파운드까지의 배낭 크기를 나타낸다. 각 행은 선택할 물건을 나타낸다. 각 칸의 가치는 다음과 같은 공식으로 동일하게 계산할 수 있다.

cell[행][열]의 최대값
 - 지금까지 구한 cell[행-1][열]의 값 중에서 가장 최대값 or
 - 현재 물건의 가치 + 남은 공간의 가치


## 02. 배낭 채우기 문제에서 자주하는 질문

- 만약 물건이 추가되면 어떻게 되나요?
격자에 추가된 물건의 행을 추가해서 같은 방식으로 물건을 풀면 된다.

- 만약 행의 순서가 바뀌면 어떻게 되나요?
행 순서를 바꾸더라도 답은 바뀌지 않는다. 즉 행의 순서는 영향을 미치지 않는다.

- 격자를 행 방향이 아니라 열 방향으로 채워도 되나요?
이 경우에도 역시 배낭채우기 문제에서는 아무 차이도 없다. 하지만 다른 문제에서는 달라질 수도 있다.

- 만약 더 작은 물건을 추가하면 어떻게 되나요?
훔칠 수 있는 물건으로 목걸이가 추가되었는데 이 물건의 무게가 0.5파운드라고 가정하자. 지금까지 물건의 무게가 모두 정수라고 가정했는데, 0.5파운드짜리 목걸이를 훔친다면 가방에 추가로 더 들어갈 수 있는 무게는 3.5파운드가 된다. 이제 3.5파운드 짜리 배낭에 대한 최대가치를 구해야 한다. 즉 목걸이를 훔치려면 배낭의 종류를 더 세분화해야 한다. 격자는 0.5 단위로 변경된다.

- 물건의 일부만 훔칠 수도 있나요?
동적 프로그래밍으로는 이 문제를 풀 수 없다. 동적 프로그래밍으로 문제를 풀려면 물건 하나를 통으로 훔치든가 아예 훔치지 않든가 하는 문제 뿐이다. 하지만 이런 경우는 탐욕 알고리즘으로 쉽게 풀 수 있다.

- 서로 의존적인 물건을 다루는 방법이 있나요?
만약에 런던 여행 계획을 세우기 위해서 동적 프로그래밍을 사용했다고 가정하자. 그러다 파리 여행도 가고 싶어져서 에펠탑과 루브르 박물관, 노틀담 대성당을 약 1.5일 소요시간으로 추가했다. 이 정소들을 가려면 런던에서 파리까지 가야하기 때문에 시간이 많이 걸린다. 런던에서 파리까지만 반나절이 걸린다. 그런데 만약 이 세군데를 모두 방문하려면 이 값을 다 더한 4.5일이 걸릴까? 그렇지 않다. 세군데를 모두 돌면 각 장소당 하루 + 파리까지 반나절로 총 3.5일이 걸린다. 이런 식으로 하위 문제들이 서로 의존하는 경우에는 동적 프로그래밍으로 문제를 풀 수 없다.


## 03. 최장 공통 부분 문자열

- 모든 동적 프로그래밍의 답안에는 격자가 있다.
- 격자의 각 칸에는 최적화하고자 하는 값을 적는다.
- 각 칸은 원래 문제에 대한 하위 문제이고, 다른 문제를 하위 문제로 가질 수 있다.


만약 당신이 dictionary.com 이라는 웹 서비스를 운영하고 있다고 가정하자.
사용자가 "fish"라는 단어를 찾아보고 싶었는데, 실수로 "hish"라고 입력했다.
사용자가 입력한 "hish"라는 단어는 "fish"를 뜻할까, 아니면 "vista"를 뜻할까?

이 문제의 격자를 만들기 위해서 아래와 같은 질문에 답해야 한다.
- 각 칸에 넣을 숫자는 무엇인가?
- 이 문제를 어떻게 하위 문제로 나눌 수 있는가?
- 격자의 축은 무엇인가?

동적 프로그래밍에서는 무언가를 최대화 하는 것이 목표다. 이 경우에는 두 단어에서 공통적으로 가지는 가장 긴 부분 문자열, 즉 최장 공통 부분 문자열(Longest Common Substring)을 찾는 것이다.


만약 알렉스가 실수로 "fosh"라고 입력했다고 가정하자.
원래 입력하려고 했던 단어는 "fish"일까 아니면 "Fort"일까?

두 단어를 최장 공통 부분 문자열 공식으로 비교하면 답은 두 글자로 같다.
하지만 Fosh가 fish에 더 가까운 단어이다.
사실은 최장 공통 부분 문자열의 길이가 아니라 최장 공통 부분열(Longest common subsequence) 즉 두 단어에서 순서가 바뀌지 않고 공통으로 들어간 글자 개수를 최대화하는 것이 옳다.

- 실제로 생물학자는 DNA가닥의 유사점을 찾기 위해서 최장 공통 부분열 방법을 사용한다.
- 마이크로소프트 워드 같은 프로그램에서 줄 맞추기 가능도 동적 프로그래밍을 사용한다.
