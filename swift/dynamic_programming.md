# 동적프로그래밍


## 01. 배낭채우기 문제

당신은 4파운드의 짐을 넣을 수 있는 도둑이다. 훔칠 수 있는 물거은 3개가 있다.
- 스테레오 / $3000 / 4파운드
- 노트북 / $2000 / 3파운드
- 기타 / $1500 / 1파운드


< 단순한 방법 >

모든 물건의 조합을 시도해서 각 경우의 총 가치를 모두 구해본 다음, 가장 가치가 높은 경우를 선택하면 된다. 이 방법은 가능하지만 너무 느리다. 물건을 추가할 때마다 경우의 수는 두 배가 된다. 이 알고리즘의 실행 시간은 O(2^n)시간이 된다. 물건이 32개이면 경우의 수는 40억개가 된다.


< 동적 프로그래밍 >

최적해를 계산하려면 동적 프로그래밍을 사용하면 된다. 동적 프로그래밍은 하위의 작은 문제들을 풀고, 이를 이용해서 더 큰 문제를 풀어나가는 방법이다. 모든 동적 프로그래밍 알고리즘은 격자(grid)로부터 시작한다.

배낭 채우기 문제를 풀 때 열은 1부터 4파운드까지의 배낭 크기를 나타낸다. 각 행은 선택할 물건을 나타낸다. 각 칸의 가치는 다음과 같은 공식으로 동일하게 계산할 수 있다.

cell[행][열]의 최대값
 - 지금까지 구한 cell[행-1][열]의 값 중에서 가장 최대값 or
 - 현재 물건의 가치 + 남은 공간의 가치


## 02. 배낭 채우기 문제에서 자주하는 질문

- 만약 물건이 추가되면 어떻게 되나요?
격자에 추가된 물건의 행을 추가해서 같은 방식으로 물건을 풀면 된다.

- 만약 행의 순서가 바뀌면 어떻게 되나요?
행 순서를 바꾸더라도 답은 바뀌지 않는다. 즉 행의 순서는 영향을 미치지 않는다.

- 격자를 행 방향이 아니라 열 방향으로 채워도 되나요?
이 경우에도 역시 배낭채우기 문제에서는 아무 차이도 없다. 하지만 다른 문제에서는 달라질 수도 있다.

- 만약 더 작은 물건을 추가하면 어떻게 되나요?
훔칠 수 있는 물건으로 목걸이가 추가되었는데 이 물건의 무게가 0.5파운드라고 가정하자. 지금까지 물건의 무게가 모두 정수라고 가정했는데, 0.5파운드짜리 목걸이를 훔친다면 가방에 추가로 더 들어갈 수 있는 무게는 3.5파운드가 된다. 이제 3.5파운드 짜리 배낭에 대한 최대가치를 구해야 한다. 즉 목걸이를 훔치려면 배낭의 종류를 더 세분화해야 한다. 격자는 0.5 단위로 변경된다.

- 물건의 일부만 훔칠 수도 있나요?
동적 프로그래밍으로는 이 문제를 풀 수 없다. 동적 프로그래밍으로 문제를 풀려면 물건 하나를 통으로 훔치든가 아예 훔치지 않든가 하는 문제 뿐이다. 하지만 이런 경우는 탐욕 알고리즘으로 쉽게 풀 수 있다.

- 서로 의존적인 물건을 다루는 방법이 있나요?
만약에 런던 여행 계획을 세우기 위해서 동적 프로그래밍을 사용했다고 가정하자. 그러다 파리 여행도 가고 싶어져서 에펠탑과 루브르 박물관, 노틀담 대성당을 약 1.5일 소요시간으로 추가했다. 이 정소들을 가려면 런던에서 파리까지 가야하기 때문에 시간이 많이 걸린다. 런던에서 파리까지만 반나절이 걸린다. 그런데 만약 이 세군데를 모두 방문하려면 이 값을 다 더한 4.5일이 걸릴까? 그렇지 않다. 세군데를 모두 돌면 각 장소당 하루 + 파리까지 반나절로 총 3.5일이 걸린다. 이런 식으로 하위 문제들이 서로 의존하는 경우에는 동적 프로그래밍으로 문제를 풀 수 없다.
