# 너비 우선 탐색


### 1. 시작에 앞서
너비 우선 탐색을 사용하면 두 항목 간의 최단 경로를 찾을 수 있다.
이 때 최단 경로라는 말은 여러가지를 의미할 수 있다. 예를 들면 다음과 같다.

- 체커 게임에서 가장 적은 수로 승리할 수 있는 방법을 계산하는 인공지능
- 맞춤법 검사기
- 여러분의 네트워크에서 가장 가까운 의사 선생님을 찾기

### 2. 그래프의 소개
예를 들어 트윈픽스에서 금문교까지 가는 가장 가까운 길을 찾는다고 가정하자.
우선 한 단계로 갈 수 있는 곳에 불을 켜본다. 그 다음 두 단계로 갈 수 있는 곳에 불을 켠다. 아직 금문교에 불이켜지지 않았다면 세 단계를 가본다. 그럼 금문교에 불을 켤 수 있게 된다. 금문교에 가는 가장 빠른 경로를 알 수 있게 된다.

이런 종류의 문제를 최단 경로 문제(shortest-path problem)이라고 한다. 이렇게 최단 경로 문제를 푸는 알고리즘을 너비 우선 탐색이라고 한다.

트윈픽스에서 금문교까지 가는 방법을 찾으려면 다음과 같은 절차가 필요하다.
- 문제를 그래프로 모형화한다.
- 너비 우선 탐색으로 문제를 푼다.

그래프란 연결의 집합을 모형화한 것이다. 그래프는 정점(node)과 간선(edge)로 이루어 진다.

정점은 여러 개의 다른 정점과 바로 이어질 수 있다. 이렇게 바로 이어진 정점을 이웃(neighbor)이라고 한다. 그래프는 항목들이 서로 어떻게 연결되어 있는지 모형화하는 방법이다.

### 3. 너비 우선 탐색
너비 우선 탐색은 그래프를 대상으로 하는 탐색 알고리즘이다. 너비 우선 탐색은 다음과 같은 두 가지 종류의 질문에 대답하는데 도움이 된다.

- 질문유형 1 : 정점 A에서 정점B로 가는 경로가 존재하는가?
- 질문유형 2 : 정점 A에서 정점B로 가는 최단 경로는 무엇인가?

만약 여러분이 페이스북 친구 중에서 망고 판매상을 찾으려고 한다면 일단 나의 친구 목록에서 망고 판매상을 찾아야 한다. 내 친구 중에서 아무도 망고 판매상이 없다면, 친구의 친구 목록에서 망고 판매상을 찾는다. 그러니까 만약 1촌 관계인 망고 판매상이 없을 경우에만 2촌 관계를 탐색한다. 너비 우선 탐색이 하는 일이 바로 이것이다.

이 방법은 목록에 추가한 순서대로 사람을 찾을 때만 가능하다. 이를 위한 자료구조가 있다. 큐(queue) 또는 대기열이라고 불리는 자료구조이다.

큐는 실생활에서와 완전히 똑같이 동작한다. 버스정류장에 줄을 서있다면 앞에 있는 사람이 먼저 버스를 타게 된다. 큐도 마찬가지다. 큐는 큐 안의 원소에 임의로 접근할 수 없다는 점에서 스택과 비슷하다. 큐에는 삽입과 제거라고 하는 두 가지 연산이 있다.

큐는 선입선출(FIFO) 자료 구조를 갖는다. 반대로 스택은 후입선출(LIFO) 구조이다.

### 4. 그래프의 구현

해시 테이블을 사용해서 키에 값을 할당할 수 있다. 정점에 이웃하는 정점을 할당하는 방식이다.
키나 값을 넣을 때 순서는 중요하지 않다. 해시 테이블은 순서를 가지지 않기 때문이다.

방향을 가지는 그래프를 방향 그래프(directed graph)라고 하고 방향성을 갖지 않는 그래프를 무방향 그래프(undirected graph)라고 한다. 무방향 그래프는 방향성을 갖지 않기 때문에 이어진 두 정점은 서로 이웃이 된다.

###5. 알고리즘의 구현

swift로 너비 우선 탐색 알고리즘을 구현해 보았다.
망고 판매상을 찾아서 네트워크를 탐색하는 방식이다.
```swift
func search(_ name : String) -> Bool{
    var searchQueue = [String]()
    searchQueue += graph[name]!
    var searched = [String]()

    while !searchQueue.isEmpty {
        var person = searchQueue.first!
        searchQueue.remove(at: 0)
        if searched.contains(person) == false {
            if person.last == "m" {
                print("\(person) is a mango seller!")
                return true
            } else {
                searchQueue += graph[person]!
                searched.append(person)
            }
        }
    }
    return false
}
```
너비 우선 탐색의 실행시간은 O(사람의 수 + 간선의 수)가 되고 보통 O(V+E)라고 표현한다. 
